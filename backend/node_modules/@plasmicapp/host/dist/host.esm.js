import '@plasmicapp/preamble';
import * as React from 'react';
import { isValidElement, cloneElement, useState, useCallback, createContext, useEffect, createElement, Fragment, useLayoutEffect, Component } from 'react';
import * as ReactDOM from 'react-dom';
import { createPortal } from 'react-dom';

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var root = globalThis;
root.__PlasmicFetcherRegistry = [];
function registerFetcher(fetcher, meta) {
  root.__PlasmicFetcherRegistry.push({
    fetcher: fetcher,
    meta: meta
  });
}

function isString(x) {
  return typeof x === "string";
}

function ensure(x, msg) {
  if (msg === void 0) {
    msg = "";
  }

  if (x === null || x === undefined) {
    debugger;
    msg = (isString(msg) ? msg : msg()) || "";
    throw new Error("Value must not be undefined or null" + (msg ? "- " + msg : ""));
  } else {
    return x;
  }
}

var root$1 = globalThis;

if (root$1.__PlasmicComponentRegistry == null) {
  root$1.__PlasmicComponentRegistry = [];
}

function registerComponent(component, meta) {
  root$1.__PlasmicComponentRegistry.push({
    component: component,
    meta: meta
  });
}

/**
 * Allows a component from Plasmic Studio to be repeated.
 * `isPrimary` should be true for at most one instance of the component, and
 * indicates which copy of the element will be highlighted when the element is
 * selected in Studio.
 * If `isPrimary` is `false`, and `elt` is a React element (or an array of such),
 * it'll be cloned (using React.cloneElement) and ajusted if it's a component
 * from Plasmic Studio. Otherwise, if `elt` is not a React element, the original
 * value is returned.
 */

function repeatedElement(isPrimary, elt) {
  return repeatedElementFn(isPrimary, elt);
}

var repeatedElementFn = function repeatedElementFn(isPrimary, elt) {
  if (isPrimary) {
    return elt;
  }

  if (Array.isArray(elt)) {
    return elt.map(function (v) {
      return repeatedElement(isPrimary, v);
    });
  }

  if (elt && isValidElement(elt) && typeof elt !== "string") {
    return cloneElement(elt);
  }

  return elt;
};

function setRepeatedElementFn(fn) {
  repeatedElementFn = fn;
}

function useForceUpdate() {
  var _useState = useState(0),
      setTick = _useState[1];

  var update = useCallback(function () {
    setTick(function (tick) {
      return tick + 1;
    });
  }, []);
  return update;
}

var root$2 = globalThis;

if (root$2.__PlasmicHostVersion == null) {
  root$2.__PlasmicHostVersion = "1";
}

var rootChangeListeners = [];

var PlasmicRootNodeWrapper = function PlasmicRootNodeWrapper(value) {
  var _this = this;

  this.value = value;

  this.set = function (val) {
    _this.value = val;
    rootChangeListeners.forEach(function (f) {
      return f();
    });
  };

  this.get = function () {
    return _this.value;
  };
};

var plasmicRootNode = /*#__PURE__*/new PlasmicRootNodeWrapper(null);

if (root$2.__Sub == null) {
  root$2.__Sub = {
    React: React,
    ReactDOM: ReactDOM,
    setPlasmicRootNode: setPlasmicRootNode,
    registerRenderErrorListener: registerRenderErrorListener,
    repeatedElement: repeatedElement,
    setRepeatedElementFn: setRepeatedElementFn
  };
}

function getPlasmicOrigin() {
  var params = new URL("https://fakeurl/" + location.hash.replace(/#/, "?")).searchParams;
  return ensure(params.get("origin"), "Missing information from Plasmic window.");
}

function renderStudioIntoIframe() {
  var script = document.createElement("script");
  var plasmicOrigin = getPlasmicOrigin();
  script.src = plasmicOrigin + "/static/js/studio.js";
  document.body.appendChild(script);
}

var renderCount = 0;

function setPlasmicRootNode(node) {
  // Keep track of renderCount, which we use as key to ErrorBoundary, so
  // we can reset the error on each render
  renderCount++;
  plasmicRootNode.set(node);
}
/**
 * React context to detect whether the component is rendered on Plasmic editor.
 */


var PlasmicCanvasContext = /*#__PURE__*/createContext(false);

function _PlasmicCanvasHost() {
  var _location$hash, _location$hash2;

  // If window.parent is null, then this is a window whose containing iframe
  // has been detached from the DOM (for the top window, window.parent === window).
  // In that case, we shouldn't do anything.  If window.parent is null, by the way,
  // location.hash will also be null.
  var isFrameAttached = !!window.parent;
  var isCanvas = !!((_location$hash = location.hash) != null && _location$hash.match(/\bcanvas=true\b/));
  var isLive = !!((_location$hash2 = location.hash) != null && _location$hash2.match(/\blive=true\b/)) || !isFrameAttached;
  var shouldRenderStudio = isFrameAttached && !document.querySelector("#plasmic-studio-tag") && !isCanvas && !isLive;
  var forceUpdate = useForceUpdate();
  useLayoutEffect(function () {
    rootChangeListeners.push(forceUpdate);
    return function () {
      var index = rootChangeListeners.indexOf(forceUpdate);

      if (index >= 0) {
        rootChangeListeners.splice(index, 1);
      }
    };
  }, [forceUpdate]);
  useEffect(function () {
    if (shouldRenderStudio && isFrameAttached && window.parent !== window) {
      renderStudioIntoIframe();
    }
  }, [shouldRenderStudio, isFrameAttached]);
  useEffect(function () {
    if (!shouldRenderStudio && !document.querySelector("#getlibs") && isLive) {
      var scriptElt = document.createElement("script");
      scriptElt.id = "getlibs";
      scriptElt.src = getPlasmicOrigin() + "/static/js/getlibs.js";
      scriptElt.async = false;

      scriptElt.onload = function () {
        window.__GetlibsReadyResolver == null ? void 0 : window.__GetlibsReadyResolver();
      };

      document.head.append(scriptElt);
    }
  }, [shouldRenderStudio]);

  if (!isFrameAttached) {
    return null;
  }

  if (isCanvas || isLive) {
    var appDiv = document.querySelector("#plasmic-app.__wab_user-body");

    if (!appDiv) {
      appDiv = document.createElement("div");
      appDiv.id = "plasmic-app";
      appDiv.classList.add("__wab_user-body");
      document.body.appendChild(appDiv);
    }

    return createPortal(createElement(ErrorBoundary, {
      key: "" + renderCount
    }, createElement(PlasmicCanvasContext.Provider, {
      value: isCanvas
    }, plasmicRootNode.get())), appDiv, "plasmic-app");
  }

  if (shouldRenderStudio && window.parent === window) {
    return createElement("p", null, "Your app is ready to host Plasmic Studio! ", createElement("br", null), " ", createElement("br", null), "On the ", createElement("a", {
      href: "https://studio.plasmic.app/"
    }, "Dashboard"), ", click on the", " ", createElement("i", null, "Config"), " button, and set", " ", createElement("code", null, location.origin + location.pathname), " as the host URL.", createElement("br", null), createElement("br", null), "You can find more information about app-hosting", " ", createElement("a", {
      href: "https://www.plasmic.app/learn/app-hosting/"
    }, "here"), ".");
  }

  return null;
}

var PlasmicCanvasHost = function PlasmicCanvasHost(props) {
  var enableWebpackHmr = props.enableWebpackHmr;

  var _React$useState = useState(null),
      node = _React$useState[0],
      setNode = _React$useState[1];

  useEffect(function () {
    setNode(createElement(_PlasmicCanvasHost, null));
  }, []);
  return createElement(Fragment, null, !enableWebpackHmr && createElement(DisableWebpackHmr, null), node);
};
var renderErrorListeners = [];

function registerRenderErrorListener(listener) {
  renderErrorListeners.push(listener);
  return function () {
    var index = renderErrorListeners.indexOf(listener);

    if (index >= 0) {
      renderErrorListeners.splice(index, 1);
    }
  };
}

var ErrorBoundary = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(ErrorBoundary, _React$Component);

  function ErrorBoundary(props) {
    var _this2;

    _this2 = _React$Component.call(this, props) || this;
    _this2.state = {};
    return _this2;
  }

  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {
    return {
      error: error
    };
  };

  var _proto = ErrorBoundary.prototype;

  _proto.componentDidCatch = function componentDidCatch(error) {
    renderErrorListeners.forEach(function (listener) {
      return listener(error);
    });
  };

  _proto.render = function render() {
    if (this.state.error) {
      return createElement("div", null, "Error: ", "" + this.state.error.message);
    } else {
      return this.props.children;
    }
  };

  return ErrorBoundary;
}(Component);

function DisableWebpackHmr() {
  if (process.env.NODE_ENV === "production") {
    return null;
  }

  return createElement("script", {
    type: "text/javascript",
    dangerouslySetInnerHTML: {
      __html: "\n      if (typeof window !== \"undefined\") {\n        const RealEventSource = window.EventSource;\n        window.EventSource = function(url, config) {\n          if (/[^a-zA-Z]hmr($|[^a-zA-Z])/.test(url)) {\n            console.warn(\"Plasmic: disabled EventSource request for\", url);\n            return {\n              onerror() {}, onmessage() {}, onopen() {}, close() {}\n            };\n          } else {\n            return new RealEventSource(url, config);\n          }\n        }\n      }\n      "
    }
  });
}

export { PlasmicCanvasContext, PlasmicCanvasHost, registerComponent, repeatedElement, registerFetcher as unstable_registerFetcher };
//# sourceMappingURL=host.esm.js.map
